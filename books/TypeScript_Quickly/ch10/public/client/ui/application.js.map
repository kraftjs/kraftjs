{"version":3,"file":"application.js","sourceRoot":"","sources":["../../../src/client/ui/application.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,IAAI,EAAkB,MAAM,4CAA4C,CAAC;AAClF,OAAO,EAAW,YAAY,EAAE,MAAM,0BAA0B,CAAC;AACjE,OAAO,EAAS,cAAc,EAAe,MAAM,2BAA2B,CAAC;AAC/E,OAAO,EAAE,mBAAmB,EAAE,MAAM,gCAAgC,CAAC;AACrE,OAAO,EAAE,WAAW,EAAE,MAAM,mBAAmB,CAAC;AAEhD,OAAO,EAAE,wBAAwB,EAAE,MAAM,iCAAiC,CAAC;AAC3E,OAAO,EAAE,eAAe,EAAE,MAAM,uBAAuB,CAAC;AAExD,MAAM,OAAO,WAAW;IASpB,YAAqB,gBAA0B;QAA1B,qBAAgB,GAAhB,gBAAgB,CAAU;QAL/C,iBAAiB;QACA,oBAAe,GAAG,IAAI,eAAe,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;QAC7D,6BAAwB,GAAG,IAAI,wBAAwB,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;QAC/E,gBAAW,GAAG,IAAI,WAAW,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;QAgDrD,kBAAa,GAAG,KAAK,EAAE,KAAY,EAAiB,EAAE;YACnE,KAAK,CAAC,cAAc,EAAE,CAAC;YAEvB,0FAA0F;YAC1F,mFAAmF;YACnF,IAAI,CAAC,MAAM,CAAC,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,mBAAmB,CAAC,CAAC;YAC3D,MAAM,mBAAmB,GAAG,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,mBAAmB,CAAC,CAAC;YAEnF,qCAAqC;YACrC,IAAI,CAAC,gBAAgB,EAAE,CAAC;YAExB,MAAM,QAAQ,GAAG,MAAM,mBAAmB,CAAC;YAC3C,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;QAC5B,CAAC,CAAC;QAkBe,yBAAoB,GAAG,CAAC,OAAgB,EAAE,EAAE;YACzD,QAAQ,OAAO,CAAC,IAAI,EAAE;gBAClB,KAAK,YAAY,CAAC,sBAAsB,CAAC,CAAC,OAAO,IAAI,CAAC,4BAA4B,CAAC,OAAO,CAAC,CAAC;gBAC5F,KAAK,YAAY,CAAC,eAAsB,CAAC,CAAC,OAAO,IAAI,CAAC,qBAAqB,CAAC,OAAO,CAAC,CAAC;gBACrF,KAAK,YAAY,CAAC,oBAAsB,CAAC,CAAC,OAAO,IAAI,CAAC,0BAA0B,CAAC,OAAO,CAAC,CAAC;gBAC1F,OAAO,CAAC,CAAC;oBACL,OAAO,CAAC,GAAG,CAAC,sCAAsC,OAAO,CAAC,IAAI,GAAG,CAAC,CAAC;iBACtE;aACJ;QACL,CAAC,CAAA;QArFG,IAAI,CAAC,MAAM,GAAG,IAAI,mBAAmB,CAAC,IAAI,CAAC,oBAAoB,CAAC,CAAC;QACjE,IAAI,CAAC,IAAI,GAAG,IAAI,cAAc,EAAE,CAAC;QAEjC,IAAI,CAAC,gBAAgB,EAAE,CAAC;QACxB,IAAI,CAAC,oBAAoB,EAAE,CAAC;IAChC,CAAC;IAEO,KAAK,CAAC,oBAAoB;QAC9B,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,mBAAmB,EAAE,CAAC;QACvD,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;YACnB,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC;SACpC;aAAM;YACH,MAAM,IAAI,CAAC,IAAI,CAAC,0BAA0B,EAAE,CAAC;SAChD;QAED,IAAI,CAAC,gBAAgB,EAAE,CAAC;IAC5B,CAAC;IAED,MAAM;QACF,OAAO,IAAI,CAAA;;;iBAGF,IAAI,CAAC,UAAU;mBACb,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC;;2BAE9B,IAAI,CAAC,aAAa;cAC/B,IAAI,CAAC,wBAAwB,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC;;;mBAG1C,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC;;KAEtD,CAAC;IACF,CAAC;IAED,IAAY,UAAU;QAClB,OAAO,IAAI,CAAA;WAEP,IAAI,CAAC,IAAI,CAAC,YAAY,CAAU,CAAC,CAAC,kCAAkC,CAAC,CAAC;YAClE,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAc,CAAC,CAAC,yBAAyB,CAAC,CAAC;gBACzD,IAAI,CAAC,IAAI,CAAC,qBAAqB,CAAC,CAAC,CAAC,kCAAkC,CAAC,CAAC;oBAClE,8BAChB;KACH,CAAC;IACF,CAAC;IAiBO,KAAK,CAAC,QAAQ,CAAC,KAAY,EAAE,YAAY,GAAG,IAAI;QACpD,yFAAyF;QACzF,mEAAmE;QACnE,IAAI;YACA,MAAM,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;YAChC,IAAI,YAAY,EAAE;gBACd,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC;aACvC;SACJ;QAAC,OAAO,KAAK,EAAE;YACZ,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;SAC9B;QAED,2DAA2D;QAC3D,IAAI,CAAC,gBAAgB,EAAE,CAAC;IAC5B,CAAC;IAaO,4BAA4B,CAAC,OAAgB;QACjD,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;YACb,IAAI,EAAE,YAAY,CAAC,uBAAuB;YAC1C,aAAa,EAAE,OAAO,CAAC,aAAa;YACpC,OAAO,EAAE,IAAI,CAAC,IAAI,CAAC,KAAK;SAC3B,CAAC,CAAC;IACP,CAAC;IAEO,KAAK,CAAC,qBAAqB,CAAC,OAAgB;QAChD,MAAM,YAAY,GAAG,OAAO,CAAC,OAAwB,CAAC;QACtD,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,YAAY,CAAC,CAAC;QAC7D,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;IAC5B,CAAC;IAEO,KAAK,CAAC,0BAA0B,CAAC,OAAgB;QACrD,MAAM,QAAQ,GAAG,OAAO,CAAC,OAAgB,CAAC;QAC1C,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;IACnC,CAAC;CACJ","sourcesContent":["import { html, TemplateResult } from '../../../node_modules/lit-html/lit-html.js';\nimport { Message, MessageTypes } from '../../shared/messages.js';\nimport { Block, BlockchainNode, Transaction } from '../lib/blockchain-node.js';\nimport { WebsocketController } from '../lib/websocket-controller.js';\nimport { BlocksPanel } from './blocks-panel.js';\nimport { Callback, Renderable } from './common.js';\nimport { PendingTransactionsPanel } from './pending-transactions-panel.js';\nimport { TransactionForm } from './transaction-form.js';\n\nexport class Application implements Renderable<void> {\n    private readonly node: BlockchainNode;\n    private readonly server: WebsocketController;\n\n    // UI components:\n    private readonly transactionForm = new TransactionForm(this.requestRendering);\n    private readonly pendingTransactionsPanel = new PendingTransactionsPanel(this.requestRendering);\n    private readonly blocksPanel = new BlocksPanel(this.requestRendering);\n\n    constructor(readonly requestRendering: Callback) {\n        this.server = new WebsocketController(this.handleServerMessages);\n        this.node = new BlockchainNode();\n\n        this.requestRendering();\n        this.initializeBlockchain();\n    }\n\n    private async initializeBlockchain() {\n        const blocks = await this.server.requestLongestChain();\n        if (blocks.length > 0) {\n            this.node.initializeWith(blocks);\n        } else {\n            await this.node.initializeWithGenesisBlock();\n        }\n\n        this.requestRendering();\n    }\n\n    render(): TemplateResult {\n        return html`\n      <main>\n        <h1>Blockchain node</h1>\n        <aside>${this.statusLine}</aside>\n        <section>${this.transactionForm.render(this.node)}</section>\n        <section>\n          <form @submit=\"${this.generateBlock}\">\n            ${this.pendingTransactionsPanel.render(this.node)}\n          </form>\n        </section>\n        <section>${this.blocksPanel.render(this.node.chain)}</section>\n      </main>\n    `;\n    }\n\n    private get statusLine(): TemplateResult {\n        return html`\n      <p>${\n            this.node.chainIsEmpty          ? '‚è≥ Initializing the blockchain...' :\n                this.node.isMining              ? '‚è≥ Mining a new block...' :\n                    this.node.noPendingTransactions ? 'üì© Add one or more transactions.' :\n                        '‚úÖ Ready to mine a new block.'\n        }</p>\n    `;\n    }\n\n    private readonly generateBlock = async (event: Event): Promise<void> => {\n        event.preventDefault();\n\n        // Let everyone in the network know about transactions need to be added to the blockchain.\n        // Every node will try to generate a new block first for the provided transactions.\n        this.server.requestNewBlock(this.node.pendingTransactions);\n        const miningProcessIsDone = this.node.mineBlockWith(this.node.pendingTransactions);\n\n        // Updates status and disables forms.\n        this.requestRendering();\n\n        const newBlock = await miningProcessIsDone;\n        this.addBlock(newBlock);\n    };\n\n    private async addBlock(block: Block, notifyOthers = true): Promise<void> {\n        // The addBlock() method returns a promise that is  rejected if the block cannot be added\n        // to the chain. Hence wrap the addBlock() call in the try / catch.\n        try {\n            await this.node.addBlock(block);\n            if (notifyOthers) {\n                this.server.announceNewBlock(block);\n            }\n        } catch (error) {\n            console.log(error.message);\n        }\n\n        // Updates status, enables forms and renders the new block.\n        this.requestRendering();\n    }\n\n    private readonly handleServerMessages = (message: Message) => {\n        switch (message.type) {\n            case MessageTypes.GetLongestChainRequest: return this.handleGetLongestChainRequest(message);\n            case MessageTypes.NewBlockRequest       : return this.handleNewBlockRequest(message);\n            case MessageTypes.NewBlockAnnouncement  : return this.handleNewBlockAnnouncement(message);\n            default: {\n                console.log(`Received message of unknown type: \"${message.type}\"`);\n            }\n        }\n    }\n\n    private handleGetLongestChainRequest(message: Message): void {\n        this.server.send({\n            type: MessageTypes.GetLongestChainResponse,\n            correlationId: message.correlationId,\n            payload: this.node.chain\n        });\n    }\n\n    private async handleNewBlockRequest(message: Message): Promise<void> {\n        const transactions = message.payload as Transaction[];\n        const newBlock = await this.node.mineBlockWith(transactions);\n        this.addBlock(newBlock);\n    }\n\n    private async handleNewBlockAnnouncement(message: Message): Promise<void> {\n        const newBlock = message.payload as Block;\n        this.addBlock(newBlock, false);\n    }\n}\n"]}